# Исследование хеш-функций (и хеш-таблиц)
## Хеш-функции
Для измерения равномерности распределения хеш-функций было сгенерировано $10^6$ ключей разных типов. Все эти ключи помещались в хеш-таблицу, сделанную методом цепочек, а затем измерялось количество ключей в каждом из листов.
### INT
Для теста было взято 3 хеш-функции: 1-ая берет число по некоторому модулю (в моем случае - 1000), 2-ая возвращает битовое представление числа в unsigned, 3-я - мультипликативная.

Ниже представлено сравнение равномерности распределения для этих функций:
![BIT](https://github.com/ThreadJava800/HashLaba/blob/main/graphics/intBit.png)\
![MUL](https://github.com/ThreadJava800/HashLaba/blob/main/graphics/intMul.png)\
![MOD](https://github.com/ThreadJava800/HashLaba/blob/main/graphics/intMod.png)

Из графиков видно, что хеш, берущий число по модулю оказался наилучшим из рассмотренных.
### FLOAT
Для float-чисел были взяты 2 хеш-функции: первая просто переводит число в int, вторая представляет число побитово, как и в int случае.

Сравнение хеш-функций:
![BIT](https://github.com/ThreadJava800/HashLaba/blob/main/graphics/floatBit.png)\
![INT](https://github.com/ThreadJava800/HashLaba/blob/main/graphics/floatInt.png)

Легко видеть, что хеш, переводящий число в int показывает себя лучше, чем побитовое представление.
### Строки
Для строк было выбрано 4 хеш-функции:\
1. Длина строки
2. Сумма букв
3. Полиномиальный
4. CRC32

Отдельно рассмотрим 1-ый хеш:\
![LEN](https://github.com/ThreadJava800/HashLaba/blob/main/graphics/charLen.png)

Как видим, в силу того, что длины слов редко превышают 10 символов, то хеш-функция не является равномерной.

Сравним оставшиеся три функции:\
![3f](https://github.com/ThreadJava800/HashLaba/blob/main/graphics/charHash.png)

Посчитав среднеквадратичное отклонение, получим, что функции в среднем схожи, однако полиномиальный хеш немного выигрывает:
| Функция | Отклонение |
|---|---|
| Сумма | 566 |
| Полиномиальный | 564 |
| CRC32 | 568 |

## Исследование хеш-таблиц
Было написано две версии хеш-таблицы (методом открытого и закрытого хеширования). Для обеих версий было замерено время работы различных операций с ними.

Для начала было замерено время работы для $10^6$ операций добавления, удаления и поиска:
| Хеш-таблица | Время работы (с) |
|---|---|
| Методом открытого хеширования | 4123 ($10^6$ операций) |
| Методом закрытого хеширования | 4615 ($230 * 10^3$ операций) |

Затем было замерено время работы для $10^6$ операция добавления (вероятность - 0.5), удаления и поиска (вероятности - по 0.25).
| Хеш-таблица | Время работы |
|---|---|
| Методом открытого хеширования | 4147 ($10^6$ операций) |
| Методом закрытого хеширования | 4612 ($260 * 10^3$ операций) |

Как видим, даже $230 * 10^3$ операций в хеш-таблице методом закрытого хеширования работают дольше, чем миллион операций в таблице методом цепочек, поэтому дальше проводить тестирование нецелесообразно. Это лучше видно на графиках:\
![time](https://github.com/ThreadJava800/HashLaba/blob/main/graphics/time.png)